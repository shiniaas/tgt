bs_aio.c:	unsigned int scsi_op = (unsigned int)cmd->scb[0];
bs_aio.c:	iocb->u.c.offset = cmd->offset;
bs_aio.c:		list_del(&cmd->bs_list);
bs_aio.c:			list_add(&cmd->bs_list, &info->cmd_wait_list);
bs_aio.c:	struct scsi_lu *lu = cmd->dev;
bs_aio.c:	unsigned int scsi_op = (unsigned int)cmd->scb[0];
bs_aio.c:	list_add_tail(&cmd->bs_list, &info->cmd_wait_list);
bs_aio.c:	switch (cmd->scb[0]) {
bs.c:		list_del(&cmd->bs_list);
bs.c:		list_add_tail(&cmd->bs_list, &ack_list);
bs.c:		list_del(&cmd->bs_list);
bs.c:		list_del(&cmd->bs_list);
bs.c:		list_del(&cmd->bs_list);
bs.c:		list_add_tail(&cmd->bs_list, &finished_list);
bs.c:	struct scsi_lu *lu = cmd->dev;
bs.c:		cmd->offset, scsi_get_in_length(cmd), nodeid);
bs.c:	list_add_tail(&cmd->bs_list, &info->pending_list[nodeid]);
bs_rdwr.c:	ret = fdatasync(cmd->dev->fd);
bs_rdwr.c:	int ret, fd = cmd->dev->fd;
bs_rdwr.c:	uint64_t offset = cmd->offset;
bs_rdwr.c:	uint32_t tl     = cmd->tl;
bs_rdwr.c:	switch (cmd->scb[0])
bs_rdwr.c:		if (cmd->scb[1] & 0x10)
bs_rdwr.c:		length = (cmd->scb[0] == SYNCHRONIZE_CACHE) ? 0 : 0;
bs_rdwr.c:		if (cmd->scb[1] & 0x2) {
bs_rdwr.c:			pg = find_mode_page(cmd->dev, 0x08, 0);
bs_rdwr.c:			if (((cmd->scb[0] != WRITE_6) && (cmd->scb[1] & 0x8)) ||
bs_rdwr.c:		if ((cmd->scb[0] != WRITE_6) && (cmd->scb[1] & 0x10))
bs_rdwr.c:		if (cmd->scb[1] & 0x08) {
bs_rdwr.c:			blocksize = 1 << cmd->dev->blk_shift;
bs_rdwr.c:			switch(cmd->scb[1] & 0x06) {
bs_rdwr.c:		for (i = 0; i < cmd->nr_sior; i ++) {
bs_rdwr.c:			ior = &(cmd->sior[i]);
bs_rdwr.c:			if ((ior->offset + cb->cbs) < cmd->dev->size)
bs_rdwr.c:				sio_size = cmd->dev->size - ior->offset - (uint64_t) ior->in_offset;
bs_rdwr.c:			if ((cmd->scb[0] != READ_6) && (cmd->scb[1] & 0x10))
bs_rdwr.c:		ret = posix_fadvise(fd, offset, cmd->tl,
bs_rdwr.c:		if (cmd->scb[1] & 0x10)
bs_rdwr.c:		if (!cmd->dev->attrs.thinprovisioning) {
bs_rdwr.c:			offset = offset << cmd->dev->blk_shift;
bs_rdwr.c:			tl = tl << cmd->dev->blk_shift;
bs_rdwr.c:			if (offset + tl > cmd->dev->size) {
bs_rdwr.c:	dprintf("io done %p %x %d %u\n", cmd, cmd->scb[0], ret, length);
bs_rdwr.c:			cmd, cmd->scb[0], ret, length, offset);
bs_sg.c:	ret = cmd->dev->bst->bs_cmd_submit(cmd);
bs_sg.c:	cmd->offset = 0;
bs_sg.c:	struct scsi_lu *dev = cmd->dev;
bs_sg.c:	io_hdr.request_len = cmd->scb_len;
bs_sg.c:	io_hdr.request = (unsigned long )cmd->scb;
bs_sg.c:	io_hdr.max_response_len = sizeof(cmd->sense_buffer);
bs_sg.c:	io_hdr.response = (unsigned long)cmd->sense_buffer;
bs_sg.c:	dprintf("[%d] Calling graceful_write for CDB: 0x%02x\n", getpid(), cmd->scb[0]);
bs_sg.c:	struct scsi_lu *dev = cmd->dev;
bs_sg.c:	io_hdr.cmd_len = cmd->scb_len;
bs_sg.c:	io_hdr.cmdp = cmd->scb;
bs_sg.c:	io_hdr.mx_sb_len = sizeof(cmd->sense_buffer);
bs_sg.c:	io_hdr.sbp = cmd->sense_buffer;
bs_sg.c:		cmd->sense_len = SCSI_SENSE_BUFFERSIZE;
bs_sg.c:		cmd->sense_len = io_hdr.sb_len_wr;
bs_ssc.c:		memcpy(cmd->sense_buffer + 3, info, 4);
bs_ssc.c:		cmd->sense_buffer[0] |= 0x80;
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	fd = cmd->dev->fd;
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	if (skip_prev_header(cmd->dev)) {
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	if (skip_next_header(cmd->dev)) {
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:			if (skip_next_header(cmd->dev)) {
bs_ssc.c:			if (skip_prev_header(cmd->dev)) {
bs_ssc.c:				skip_next_header(cmd->dev);
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	length = min(length, get_unaligned_be24(&cmd->scb[2]));
bs_ssc.c:	ret = pread64(cmd->dev->fd, buf, length, h->curr + SSC_BLK_HDR_SIZE);
bs_ssc.c:	ret = skip_next_header(cmd->dev);
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	uint32_t block_length = ssc_get_block_length(cmd->dev);
bs_ssc.c:	count = get_unaligned_be24(&cmd->scb[2]);
bs_ssc.c:	fd = cmd->dev->fd;
bs_ssc.c:			skip_next_header(cmd->dev);
bs_ssc.c:		if (skip_next_header(cmd->dev)) {
bs_ssc.c:	struct ssc_info *ssc = dtype_priv(cmd->dev);
bs_ssc.c:	uint32_t block_length = ssc_get_block_length(cmd->dev);
bs_ssc.c:	ssc = dtype_priv(cmd->dev);
bs_ssc.c:	switch (cmd->scb[0]) {
bs_ssc.c:		if (resp_rewind(cmd->dev)) {
bs_ssc.c:		ret = get_unaligned_be24(&cmd->scb[2]);
bs_ssc.c:		fsync(cmd->dev->fd);
bs_ssc.c:		fixed = cmd->scb[1] & 1;
bs_ssc.c:		sti = cmd->scb[1] & 2;
bs_ssc.c:		count = get_unaligned_be24(&cmd->scb[2]);
bs_ssc.c:		fixed = cmd->scb[1] & 1;
bs_ssc.c:		count = get_unaligned_be24(&cmd->scb[2]);
bs_ssc.c:		code = cmd->scb[1] & 0xf;
bs_ssc.c:		count = be24_to_2comp(&cmd->scb[2]);
bs_ssc.c:				if (skip_next_header(cmd->dev)) {
bs_ssc.c:		int service_action = cmd->scb[1] & 0x1f;
bs_ssc.c:	dprintf("io done %p %x %d %u\n", cmd, cmd->scb[0], ret, length);
bs_ssc.c:			cmd, cmd->scb[0], ret, length, cmd->offset);
cache.c:	 *     cmd->offset
cache.c:	 *                      cmd->offset + length
cache.c:	cmd->nr_sior = 0;
cache.c:	a_shadow = (uint64_t) (cmd->offset / hc->cbs) * hc->cbs;
cache.c:	b_shadow = (uint64_t) (((cmd->offset + length) / hc->cbs) + 1) * hc->cbs;
cache.c:	cmd->nr_sior = (b_shadow - a_shadow) / hc->cbs;
cache.c:	for (i = 0; i < cmd->nr_sior; i ++) {
cache.c:		ior = &(cmd->sior[i]);
cache.c:		if (cmd->nr_sior == 1) {		/* first and last */
cache.c:			ior->in_offset = (uint32_t) cmd->offset - a_shadow;
cache.c:			ior->in_offset = (uint32_t) cmd->offset - a_shadow;
cache.c:		} else if (i == cmd->nr_sior - 1) {	/* last sub io */
cache.c:			ior->m_offset = i * hc->cbs  - (cmd->offset - a_shadow);
cache.c:			ior->length = hc->cbs - (b_shadow - (cmd->offset + length));
cache.c:			ior->m_offset = i * hc->cbs  - (cmd->offset - a_shadow);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:		switch (cmd->scb[0]) {
mmc.c:		switch (cmd->scb[0]) {
mmc.c:	offset = scsi_rw_offset(cmd->scb);
mmc.c:	cmd->offset = (offset << MMC_BLK_SHIFT);
mmc.c:	length = scsi_rw_count(cmd->scb);
mmc.c:	end_offset = cmd->offset + (length << MMC_BLK_SHIFT);
mmc.c:	if (end_offset > cmd->dev->size)
mmc.c:		cmd->dev->size = end_offset;
mmc.c:	ret = cmd->dev->bst->bs_cmd_submit(cmd);
mmc.c:		cmd->offset = 0;
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	size = cmd->dev->size >> MMC_BLK_SHIFT;
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	if (!cmd->dev->attrs.online) {
mmc.c:	toc_time = cmd->scb[1] & 0x02;
mmc.c:	toc_format = cmd->scb[2] & 0x0f;
mmc.c:	toc_track = cmd->scb[6];
mmc.c:			tsa = cmd->dev->size >> MMC_BLK_SHIFT; /* lba */
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	attrs = &cmd->dev->attrs;
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	rt = cmd->scb[1] & 0x03;
mmc.c:	start = cmd->scb[2];
mmc.c:	start = (start << 8) | cmd->scb[3];
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:		tmp = cmd->dev->size >> MMC_BLK_SHIFT;
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:		tmp = cmd->dev->size >> MMC_BLK_SHIFT;
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	type = cmd->scb[1]&0x03;
mmc.c:	lba = cmd->scb[2];
mmc.c:	lba = (lba<<8) | cmd->scb[3];
mmc.c:	lba = (lba<<8) | cmd->scb[4];
mmc.c:	lba = (lba<<8) | cmd->scb[5];
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	blocks = cmd->scb[1]&0x01;
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:		tmp = (cmd->dev->size >> MMC_BLK_SHIFT) - 1;
mmc.c:	data_type = cmd->scb[1]&0x1f;
mmc.c:	lba = cmd->scb[2];
mmc.c:	lba = (lba<<8)|cmd->scb[3];
mmc.c:	lba = (lba<<8)|cmd->scb[4];
mmc.c:	lba = (lba<<8)|cmd->scb[5];
mmc.c:	num_desc = cmd->scb[8];
mmc.c:	num_desc = (num_desc<<8)|cmd->scb[9];
mmc.c:	type = cmd->scb[10];
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	address = cmd->scb[2];
mmc.c:	address = (address<<8) | cmd->scb[3];
mmc.c:	address = (address<<8) | cmd->scb[4];
mmc.c:	address = (address<<8) | cmd->scb[5];
mmc.c:	layer = cmd->scb[6];
mmc.c:	format = cmd->scb[7];
mmc.c:	struct mmc_info *mmc = dtype_priv(cmd->dev);
mmc.c:	tmp = cmd->scb[5];
mmc.c:	tmp = (tmp << 8) | cmd->scb[6];
mmc.c:	tmp = (tmp << 8) | cmd->scb[7];
mmc.c:	tmp = (tmp << 8) | cmd->scb[8];
mmc.c:	uint8_t *scb = cmd->scb;
osd.c:	return cmd->dev->bst->bs_cmd_submit(cmd);
sbc.c:	pg = find_mode_page(cmd->dev, pcode, subpcode);
sbc.c:	if (cmd->dev->attrs.readonly && ret == SAM_STAT_GOOD) {
sbc.c:		mode6 = (cmd->scb[0] == 0x1a);
sbc.c:	if (!cmd->dev->attrs.online) {
sbc.c:	if (cmd->dev->attrs.readonly) {
sbc.c:	if (cmd->scb[1] & 0x80) {
sbc.c:	if (cmd->scb[1] & 0x10) {
sbc.c:	if (cmd->scb[1] & 0x07) {
sbc.c:	struct scsi_lu *lu = cmd->dev;
sbc.c:	anchor = cmd->scb[1] & 0x01;
sbc.c:	ret = cmd->dev->bst->bs_cmd_submit(cmd);
sbc.c:	cmd->offset = 0;
sbc.c:	struct scsi_lu *lu = cmd->dev;
sbc.c:	if (cmd->dev->attrs.removable && !cmd->dev->attrs.online) {
sbc.c:	switch (cmd->scb[0]) {
sbc.c:		if (cmd->scb[1] & 0xe0) {
sbc.c:		if (cmd->scb[1] & 0x10) {
sbc.c:		if (cmd->scb[1] & 0x08 && !lu->attrs.thinprovisioning) {
sbc.c:		if (cmd->scb[1] & 0xe0) {
sbc.c:		if ((cmd->scb[1] & 0x06) == 0x06) {
sbc.c:		switch (cmd->scb[0]) {
sbc.c:	lba = scsi_rw_offset(cmd->scb);
sbc.c:	tl  = scsi_rw_count(cmd->scb);
sbc.c:		    lba + tl > lu->size >> cmd->dev->blk_shift) {
sbc.c:	        if (lba >= lu->size >> cmd->dev->blk_shift) {
sbc.c:	cmd->offset = lba << cmd->dev->blk_shift;
sbc.c:	cmd->tl     = tl  << cmd->dev->blk_shift;
sbc.c:	ret = cmd->dev->bst->bs_cmd_submit(cmd);
sbc.c:	cmd->offset = 0;
sbc.c:	ret = device_release(cmd->c_target->tid, cmd->cmd_itn_id,
sbc.c:			     cmd->dev->lun, 0);
sbc.c:	uint8_t *scb = cmd->scb;
sbc.c:	if (cmd->dev->attrs.removable && !cmd->dev->attrs.online) {
sbc.c:	bshift = cmd->dev->blk_shift;
sbc.c:	size = cmd->dev->size >> bshift;
sbc.c:	struct scsi_lu *lu = cmd->dev;
sbc.c:	if (cmd->dev->attrs.removable && !cmd->dev->attrs.online) {
sbc.c:	vprotect = cmd->scb[1] & 0xe0;
sbc.c:	bytchk = cmd->scb[1] & 0x02;
sbc.c:	lba = scsi_rw_offset(cmd->scb);
sbc.c:	tl  = scsi_rw_count(cmd->scb);
sbc.c:		    lba + tl > lu->size >> cmd->dev->blk_shift) {
sbc.c:		if (lba >= lu->size >> cmd->dev->blk_shift) {
sbc.c:	cmd->offset = lba << cmd->dev->blk_shift;
sbc.c:	ret = cmd->dev->bst->bs_cmd_submit(cmd);
sbc.c:	if (cmd->dev->attrs.removable && !cmd->dev->attrs.online) {
sbc.c:	bshift = cmd->dev->blk_shift;
sbc.c:	size = cmd->dev->size >> bshift;
sbc.c:	val = (cmd->dev->attrs.lbppbe << 16) | cmd->dev->attrs.la_lba;
sbc.c:	if (cmd->dev->attrs.thinprovisioning)
sbc.c:	if (cmd->dev->attrs.removable && !cmd->dev->attrs.online) {
sbc.c:	offset = get_unaligned_be64(&cmd->scb[2]) << cmd->dev->blk_shift;
sbc.c:	if (offset >= cmd->dev->size) {
sbc.c:		if (offset >= cmd->dev->size)
sbc.c:			find_next_hole(cmd->dev, offset) :
sbc.c:			find_next_data(cmd->dev, offset);
sbc.c:		put_unaligned_be64(offset >> cmd->dev->blk_shift,
sbc.c:				   >> cmd->dev->blk_shift,
sbc.c:	unsigned char op = cmd->scb[0];
sbc.c:	action = cmd->scb[1] & 0x1f;
sbc.c:	actions = cmd->dev->dev_type_template.ops[op].service_actions;
sbc.c:	if (cmd->dev->attrs.removable && !cmd->dev->attrs.online) {
sbc.c:	ret = cmd->dev->bst->bs_cmd_submit(cmd);
scsi.c:	if (cmd->dev->attrs.sense_format) {
scsi.c:		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
scsi.c:		cmd->sense_buffer[1] = key;
scsi.c:		cmd->sense_buffer[2] = (asc >> 8) & 0xff;
scsi.c:		cmd->sense_buffer[3] = asc & 0xff;
scsi.c:		cmd->sense_len = 8;
scsi.c:		cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
scsi.c:		cmd->sense_buffer[2] = key;
scsi.c:		cmd->sense_buffer[7] = len;
scsi.c:		cmd->sense_buffer[12] = (asc >> 8) & 0xff;
scsi.c:		cmd->sense_buffer[13] = asc & 0xff;
scsi.c:		cmd->sense_len = len + 8;
scsi.c:	unsigned char op = cmd->scb[0];
scsi.c:		cmd->itn_lu_info->stat.wr_subm_bytes += scsi_get_out_length(cmd);
scsi.c:		cmd->itn_lu_info->stat.wr_subm_cmds++;
scsi.c:		cmd->itn_lu_info->stat.rd_subm_bytes += scsi_get_in_length(cmd);
scsi.c:		cmd->itn_lu_info->stat.rd_subm_cmds++;
scsi.c:		cmd->itn_lu_info->stat.wr_subm_bytes += scsi_get_out_length(cmd);
scsi.c:		cmd->itn_lu_info->stat.rd_subm_bytes += scsi_get_in_length(cmd);
scsi.c:		cmd->itn_lu_info->stat.bidir_subm_cmds++;
scsi.c:	if (cmd->dev->lun != cmd->dev_id) {
scsi.c:				    &cmd->it_nexus->itn_itl_info_list,
scsi.c:	return cmd->dev->dev_type_template.ops[op].cmd_perform(host_no, cmd);
scsi_cmnd.h:	scmd->field = val;							\
scsi_cmnd.h:	return scmd->field;							\
scsi_cmnd.h:	scmd->dir##_sdb.field = set_cast (val);					\
scsi_cmnd.h:	return get_cast (scmd->dir##_sdb.field);				\
smc.c:	struct smc_info *smc = dtype_priv(cmd->dev);
smc.c:	scb = cmd->scb;
smc.c:	if (cmd->dev) {
smc.c:	struct smc_info *smc = dtype_priv(cmd->dev);
smc.c:	scb = cmd->scb;
spc.c:	uint8_t *scb = cmd->scb;
spc.c:	attrs = &cmd->dev->attrs;
spc.c:	if (cmd->dev->lun != cmd->dev_id)
spc.c:	struct list_head *dev_list = &cmd->c_target->device_list;
spc.c:	uint8_t *scb = cmd->scb;
spc.c:	uint8_t *scb = cmd->scb;
spc.c:	if (loej && !start && cmd->dev->attrs.removable) {
spc.c:		if (lu_prevent_removal(cmd->dev)) {
spc.c:			if (cmd->dev->attrs.online) {
spc.c:		spc_lu_offline(cmd->dev);
spc.c:	if (loej && start && cmd->dev->attrs.removable)
spc.c:		spc_lu_online(cmd->dev);
spc.c:	if (cmd->dev->attrs.online)
spc.c:	if (cmd->dev->attrs.removable)
spc.c:	uint8_t *scb = cmd->scb;
spc.c:	struct it_nexus_lu_info *itn_lu_info = cmd->itn_lu_info;
spc.c:	uint8_t *scb = cmd->scb;
spc.c:		memcpy(cmd->dev->mode_block_descriptor, data + offset,
spc.c:		pg = find_mode_page(cmd->dev, pcode, 0);
spc.c:		ua_sense_add_other_it_nexus(cmd->cmd_itn_id, cmd->dev,
spc.c:	scb = cmd->scb;
spc.c:			memcpy(data + len, cmd->dev->mode_block_descriptor,
spc.c:				    &cmd->dev->mode_pages,
spc.c:		pg = find_mode_page(cmd->dev, pcode, subpcode);
spc.c:	ops = cmd->dev->dev_type_template.ops;
spc.c:	reporting_options = cmd->scb[2] & 0x07;
spc.c:	requested_service_action = cmd->scb[4];
spc.c:	requested_service_action |= cmd->scb[5];
spc.c:	alloc_len = (uint32_t)cmd->scb[6] << 24 |
spc.c:		(uint32_t)cmd->scb[7] << 16 |
spc.c:		(uint32_t)cmd->scb[8] << 8 |
spc.c:		(uint32_t)cmd->scb[9];
spc.c:	rctd = cmd->scb[2] & 0x80;
spc.c:	if (!(cmd->scb[1] & 0x04))
spc.c:	unsigned char op = cmd->scb[0];
spc.c:	action = cmd->scb[1] & 0x1f;
spc.c:	actions = cmd->dev->dev_type_template.ops[op].service_actions;
spc.c:	len = get_unaligned_be16(cmd->scb + 7);
spc.c:	put_unaligned_be32(cmd->dev->prgeneration, &buf[0]);
spc.c:	list_for_each_entry(reg, &cmd->dev->registration_list,
spc.c:	reg = cmd->dev->pr_holder;
spc.c:	if (get_unaligned_be16(cmd->scb + 7) < len)
spc.c:	put_unaligned_be32(cmd->dev->prgeneration, &buf[0]);
spc.c:	len = get_unaligned_be16(cmd->scb + 7);
spc.c:	if (get_unaligned_be16(cmd->scb + 7) < len)
spc.c:	force = ((cmd->scb[1] & 0x1f) == PR_OUT_REGISTER_AND_IGNORE_EXISTING_KEY);
spc.c:	reg = lookup_registration_by_nexus(cmd->dev, cmd->it_nexus);
spc.c:				__unregister(cmd->dev, reg);
spc.c:				reg->nexus_id = cmd->cmd_itn_id;
spc.c:				reg->ctime = cmd->it_nexus->ctime;
spc.c:					      &cmd->dev->registration_list);
spc.c:	cmd->dev->prgeneration++;
spc.c:	pr_scope = (cmd->scb[2] & 0xf0) >> 4;
spc.c:	pr_type = cmd->scb[2] & 0x0f;
spc.c:	reg = lookup_registration_by_nexus(cmd->dev, cmd->it_nexus);
spc.c:	holder = cmd->dev->pr_holder;
spc.c:		if (!is_pr_holder(cmd->dev, reg))
spc.c:	cmd->dev->pr_holder = reg;
spc.c:	pr_scope = (cmd->scb[2] & 0xf0) >> 4;
spc.c:	pr_type = cmd->scb[2] & 0x0f;
spc.c:	reg = lookup_registration_by_nexus(cmd->dev, cmd->it_nexus);
spc.c:	holder = cmd->dev->pr_holder;
spc.c:	if (!is_pr_holder(cmd->dev, reg))
spc.c:	cmd->dev->pr_holder = NULL;
spc.c:	list_for_each_entry(sibling, &cmd->dev->registration_list,
spc.c:					    cmd->dev, ASC_RESERVATIONS_RELEASED);
spc.c:	reg = lookup_registration_by_nexus(cmd->dev, cmd->it_nexus);
spc.c:	holder = cmd->dev->pr_holder;
spc.c:		cmd->dev->pr_holder = NULL;
spc.c:	list_for_each_entry_safe(sibling, n, &cmd->dev->registration_list,
spc.c:				cmd->dev, ASC_RESERVATIONS_PREEMPTED);
spc.c:	cmd->dev->prgeneration++;
spc.c:	pr_scope = (cmd->scb[2] & 0xf0) >> 4;
spc.c:	pr_type = cmd->scb[2] & 0x0f;
spc.c:	reg = lookup_registration_by_nexus(cmd->dev, cmd->it_nexus);
spc.c:		ret = check_registration_key_exists(cmd->dev, sa_res_key);
spc.c:	holder = cmd->dev->pr_holder;
spc.c:				cmd->dev->pr_holder = reg;
spc.c:				cmd->dev->pr_holder = reg;
spc.c:	list_for_each_entry_safe(sibling, n, &cmd->dev->registration_list,
spc.c:				cmd->dev, ASC_RESERVATIONS_PREEMPTED);
spc.c:			__unregister(cmd->dev, sibling);
spc.c:				cmd->dev, ASC_RESERVATIONS_RELEASED);
spc.c:	cmd->dev->prgeneration++;
spc.c:	if (get_unaligned_be16(cmd->scb + 7) < len)
spc.c:	reg = lookup_registration_by_nexus(cmd->dev, cmd->it_nexus);
spc.c:		if (cmd->dev->pr_holder)
spc.c:	if (!is_pr_holder(cmd->dev, reg))
spc.c:	list_for_each_entry(dst, &cmd->dev->registration_list,
spc.c:	id = tgt_drivers[cmd->c_target->lid]->transportid;
spc.c:		idlen = id(cmd->dev->tgt->tid, dst->nexus_id, tpid, sizeof(tpid));
spc.c:	cmd->dev->pr_holder = dst;
spc.c:		__unregister(cmd->dev, reg);
spc.c:	cmd->dev->prgeneration++;
spc.c:	unsigned char op = cmd->scb[0];
spc.c:	if (!cmd->dev->pr_holder)
spc.c:	reg = lookup_registration_by_nexus(cmd->dev, cmd->it_nexus);
spc.c:	if (reg && is_pr_holder(cmd->dev, reg))
spc.c:	pr_type = cmd->dev->pr_holder->pr_type;
spc.c:	bits = cmd->dev->dev_type_template.ops[op].pr_conflict_bits;
spc.c:	memcpy(data, cmd->sense_buffer, min_t(uint32_t, len, cmd->sense_len));
spc.c:	scsi_set_in_resid_by_actual(cmd, cmd->sense_len);
spc.c:	memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
spc.c:	cmd->sense_len = 0;
spc.c:	uint8_t *cdb = cmd->scb;
spc.c:	switch(cmd->scb_len) {
ssc.c:	mode6 = (cmd->scb[0] == 0x1a);
ssc.c:	if (cmd->dev->attrs.readonly) {
ssc.c:	if (cmd->dev->attrs.removable && !cmd->dev->attrs.online) {
ssc.c:	if (cmd->dev->attrs.readonly) {
ssc.c:		switch (cmd->scb[0]) {
ssc.c:	ret = cmd->dev->bst->bs_cmd_submit(cmd);
ssc.c:	cmd->offset = 0;
ssc.c:	uint8_t block_length = ssc_get_block_length(cmd->dev);
target.c:	struct it_nexus_lu_info *itn_lu = cmd->itn_lu_info;
target.c:	int len = sizeof(cmd->sense_buffer);
target.c:		memcpy(cmd->sense_buffer, uas->ua_sense_buffer,
target.c:		cmd->sense_len = min(uas->ua_sense_len, len);
target.c:	list_add(&cmd->c_hlist, &itn->cmd_list);
target.c:	list_del(&cmd->c_hlist);
target.c:	lu = device_lookup(cmd->c_target, cmd->dev->lun);
target.c:			cmd->c_target->tid, cmd->dev->lun);
target.c:	if (lu->reserve_id && lu->reserve_id != cmd->cmd_itn_id) {
target.c:			lu->reserve_id, cmd->cmd_itn_id);
target.c:	lu->reserve_id = cmd->cmd_itn_id;
target.c:	lu = device_lookup(cmd->c_target, cmd->dev->lun);
target.c:	if (!lu || !lu->reserve_id || lu->reserve_id == cmd->cmd_itn_id)
target.c:	if (cmd->attribute != MSG_SIMPLE_TAG)
target.c:			cmd->tag, cmd->attribute,
target.c:			cmd->dev ? cmd->dev->lun : UINT64_MAX,
target.c:	switch (cmd->attribute) {
target.c:		eprintf("unknown command attribute %x\n", cmd->attribute);
target.c:		cmd->attribute = MSG_ORDERED_TAG;
target.c:	switch (cmd->attribute) {
target.c:	uint64_t dev_id, itn_id = cmd->cmd_itn_id;
target.c:	cmd->c_target = target = itn->nexus_target;
target.c:	cmd->it_nexus = itn;
target.c:	dev_id = scsi_get_devid(target->lid, cmd->lun);
target.c:	cmd->dev_id = dev_id;
target.c:	dprintf("%p %x %" PRIx64 "\n", cmd, cmd->scb[0], dev_id);
target.c:	cmd->dev = device_lookup(target, dev_id);
target.c:	if (!cmd->dev)
target.c:		cmd->dev = list_first_entry(&target->device_list,
target.c:	cmd->itn_lu_info = it_nexus_lu_info_lookup(itn, cmd->dev->lun);
target.c:	return cmd->dev->cmd_perform(tid, cmd);
target.c:	struct tgt_cmd_queue *q = &cmd->dev->cmd_queue;
target.c:	cmd_hlist_insert(cmd->it_nexus, cmd);
target.c:	dprintf("%p %x %" PRIx64 " %d\n", cmd, cmd->scb[0], cmd->dev_id,
target.c:		result = scsi_cmd_perform(cmd->it_nexus->host_no, cmd);
target.c:			cmd->tag, cmd->scb[0], scsi_get_out_buffer(cmd),
target.c:			scsi_get_in_buffer(cmd), cmd->offset,
target.c:			cmd->tag, cmd->scb[0], cmd->dev->lun, q->active_cmd);
target.c:		list_add_tail(&cmd->qlist, &q->queue);
target.c:	dprintf("%p %x %" PRIx64 " PT\n", cmd, cmd->scb[0], cmd->dev_id);
target.c:	result = cmd->dev->dev_type_template.cmd_passthrough(tid, cmd);
target.c:		cmd->tag, cmd->scb[0], scsi_get_out_buffer(cmd),
target.c:		scsi_get_in_buffer(cmd), cmd->offset,
target.c:	struct lu_stat *stat = &cmd->itn_lu_info->stat;
target.c:	int lid = cmd->c_target->lid;
target.c:	tgt_drivers[lid]->cmd_end_notify(cmd->cmd_itn_id, result, cmd);
target.c:			int tid = cmd->c_target->tid;
target.c:			uint64_t itn_id = cmd->cmd_itn_id;
target.c:			list_del(&cmd->qlist);
target.c:			dprintf("perform %" PRIx64 " %x\n", cmd->tag,
target.c:				cmd->attribute);
target.c:	q = &cmd->dev->cmd_queue;
target.c:	q->active_cmd--;
target.c:	switch (cmd->attribute) {
target.c:	mreq = cmd->mreq;
target.c:		tgt_drivers[cmd->c_target->lid]->mgmt_end_notify(mreq);
target.c:	cmd->dev->cmd_done(cmd->c_target, cmd);
target.c:	eprintf("found %" PRIx64 " %lx\n", cmd->tag, cmd->state);
target.c:		cmd->mreq = mreq;
target.c:		cmd->dev->cmd_done(target, cmd);
target.c:			    (cmd->tag == tag && itn->itn_id == itn_id) ||
target.c:			    (lun && !memcmp(cmd->lun, lun, sizeof(cmd->lun)))) {
